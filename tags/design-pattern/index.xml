<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Design Pattern on Renjie Blog</title>
    <link>https://renjie-zhang.github.io/tags/design-pattern/</link>
    <description>Recent content in Design Pattern on Renjie Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 13 Sep 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://renjie-zhang.github.io/tags/design-pattern/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Coding Common Problem</title>
      <link>https://renjie-zhang.github.io/post/2020-09-13-coding-issue/</link>
      <pubDate>Sun, 13 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://renjie-zhang.github.io/post/2020-09-13-coding-issue/</guid>
      <description>封装的错误 工作中很多语言都是面向对象的语言，面向对象的三大特征，有时候也是四大特性，我们常说的封装、继承、多态，四大特性就需要加上抽象。我们对对象进行封装是为了更好隐藏或者数据访问保护，但是并不是所有的属性都是可以进行get与set的。这便是我们常犯的一个错误，使用Lombok的注解@Getter与@Setter直接将所有的属性暴露了，此时封装便形同虚无，完全没有达到目的。 下面用极客时间王争设计模式之美课程的一个列子来说明：
public class Wallet { private String id; private long createTime; private BigDecimal balance; private long balanceLastModifiedTime; public String getId() { return id; } public long getCreateTime() { return createTime; } public BigDecimal getBalance() { return balance; } public long getBalanceLastModifiedTime() { return balanceLastModifiedTime; } public void increaseBalance(BigDecimal increasedAmount){ if(increasedAmount.compareTo(BigDecimal.ZERO) &amp;lt; 0){ throw new Exception(&amp;quot;...&amp;quot;); } this.balance.add(increasedAmount); this.balanceLastModifiedTime = System.currentTimeMillis(); } }  这是一个虚拟钱包的大概一个实现，在我们平常的开发中，并不是很重视get与set方法，直接使用注解@Getter与@Setter，也让在修改属性返回类型，修改属性名称时很方便；但是这并不是我们的目的。对于部分属性我们是不需要对外暴露set方法，只允许get。 对于balance并没有set方法，而是封装在$increaseBalance()中，因为在修改时，需要对参数进行校验，满足条件的参数才会进行修改，这便是我们的目的，使用封装来对数据进行保护。
未完</description>
    </item>
    
  </channel>
</rss>