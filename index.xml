<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Renjie Blog</title>
    <link>https://renjie-zhang.github.io/</link>
    <description>Recent content on Renjie Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 03 Sep 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://renjie-zhang.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>约瑟夫环(Josephus) </title>
      <link>https://renjie-zhang.github.io/post/2019-08-31-josephus/</link>
      <pubDate>Tue, 03 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://renjie-zhang.github.io/post/2019-08-31-josephus/</guid>
      <description>约瑟夫问题 据说著名犹太历史学家 Josephus有过以下的故事：在罗马人占领乔塔帕特后，39 个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式：41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想遵从。首先从一个人开始，越过k-2个人（因为第一个人已经被越过），并杀掉第k个人。接着，再越过k-1个人，并杀掉第k个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。问题是一开始要站在什么地方才能避免自杀？Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。 17世纪的法国数学家加斯帕在《数目的游戏问题》中讲了这样一个故事：15个教徒和15个非教徒在深海上遇险，必须将一半的人投入海中，其余的人才能幸免于难，于是想了一个办法：30个人围成一圆圈，从第一个人开始依次报数，每数到第九个人就将他扔入大海，如此循环进行直到仅余15个人为止。问怎样排法，才能使每次投入大海的都是非教徒。 来自百度百科。
问题即，给定人数、起点、方向和要跳过的数字，选择初始圆圈中的位置以避免被处决。
解法:使用单项的循环链表模拟整个过程，时间复杂度为O(N*M),而空间复杂度为O(N)。或者使用数学公式递归的方式求出存活下来的编号。
循环链表解决 static void getPosition(int index,int total){ //first create a circle linked head Node head = new Node(1); Node prev = head; for(int i = 2;i&amp;lt;=total;i++){ prev.next = new Node(i); //move next prev = prev.next; } //create a cirecle linkedlist prev.next = head; // create two temp node Node ptr1 = head; Node ptr2 = head; while(ptr1.next != ptr1){ //find index-th node int count = 1; while (count !</description>
    </item>
    
    <item>
      <title>Queue</title>
      <link>https://renjie-zhang.github.io/post/2019-08-27-queue-ii/</link>
      <pubDate>Tue, 27 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://renjie-zhang.github.io/post/2019-08-27-queue-ii/</guid>
      <description>队列Ⅱ 使用数组实现队列的缺点是当存储的数据超过数组的长度之后就需要考虑扩容了，如果有无限排队的需求，那么就需要一个链表实现无限排队的队列，相比于数组实现队列，链表更加的简单。下面展示代码：
基于链表实现的方式（java） /** * @author: renjie.zhang * @date:2019/8/25-16:23 * @Description: 使用链表实现队列 */ public class LinkedListQueue { private Node head =new Node(0); public Node getHead() { return head; } /** * 队列入队操作 * @param node */ public void EnQueue(Node node){ Node temp = head; while (true){ if (temp.next == null){ break; } temp = temp.next; } temp.next = node; } /** * 队列出队操作 * @param head * @return */ public Node DeQueue(Node head){ if(head.</description>
    </item>
    
    <item>
      <title>Queue</title>
      <link>https://renjie-zhang.github.io/post/2019-08-22-queue/</link>
      <pubDate>Tue, 20 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://renjie-zhang.github.io/post/2019-08-22-queue/</guid>
      <description>队列Ⅰ 像堆栈一样，队列是一种线性结构，它遵循着执行操作的特定顺序。比如在开发中常用的线程池就是一个队列，当我们向固定大小的线程池中请求一个线程时，如果线程池中有空闲的资源，那么可以获得到到，但是如果没有空闲的资源，那么线程池的处理一般有两种；一种是非阻塞的处理方式，直接拒绝任务请求；另外一种是阻塞的方式，将请求排队，等到有空闲的线程时，取出排队的请求继续处理。当处理排队请求时，我们又希望公平地处理每一个请求，先进先服务。队列有基于链表与基于数组的实现方式。
 基于链表实现的队列可以实现一个无限排队的无界队列，但是可能导致过多请求排队，请求响应的时间过长，对于大部分资源有限又对响应时间敏感的系统，基于链表实现的无限排队的线程池是不适合的。 基于数据实现的队列可以实现一个有界队列，队列的大小有限，所以线程池中的排队请求超过队列的大小时，接下来的请求会被拒绝，这种对于响应时间敏感的系统来说更加的适合；但是队列的大小设置是一个十分重要的因素，队列大导致请求过多，队列小导致无法充分利用系统资源，发挥最大性能。  基于数组方式实现队列（java） public class ArrayQueue { //表示队列的最大容量 private int maxSize; //对列的头 private int front; //队列的尾 private int rear; //数组 private int[] arr; /** * 构造器 * @param arrMaxSize 队列的最大容量 */ public ArrayQueue(int arrMaxSize){ this.maxSize = arrMaxSize; this.arr = new int[maxSize]; //-1表示front的前一个位置 this.front = -1; //-1表示rear的最后一个数据 this.rear = -1; } /** *判断队列是否已装满 * @return */ public boolean isFull(){ return rear == maxSize-1; } /** * 判断队列是否为空 * @return */ public boolean isEmpty(){ return front == rear; } /** * 向队列中添加数据 * @param n 数据 */ public void addToQueue(int n){ if(isFull()){ System.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://renjie-zhang.github.io/search/placeholder/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://renjie-zhang.github.io/search/placeholder/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://renjie-zhang.github.io/top/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://renjie-zhang.github.io/top/about/</guid>
      <description>About Me 戒骄、戒躁
成长中 2015年9月-2019年6月 成都师范学院 计算机科学学院
2018年11月-至今 成都天衡智造有限公司 Java研发
爱好 篮球、健身、代码、美剧</description>
    </item>
    
    <item>
      <title></title>
      <link>https://renjie-zhang.github.io/top/books/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://renjie-zhang.github.io/top/books/</guid>
      <description> 学习笔记 </description>
    </item>
    
    <item>
      <title>collect</title>
      <link>https://renjie-zhang.github.io/post/2019-08-30-collect/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://renjie-zhang.github.io/post/2019-08-30-collect/</guid>
      <description>网站 计算机技术教程：https://www.geeksforgeeks.org/
设计模式：https://java-design-patterns.com/patterns/
算法字典：https://xlinux.nist.gov/dads/
数据结构与算法：https://java2blog.com/data-structure-and-algorithm-interview-questions-in-java/
Linux系统在线体验：https://distrotest.net/
每日文章推荐：https://www.discoverdev.io/
Hacker news: https://news.ycombinator.com/
在线工具 百度脑图： https://naotu.baidu.com/
在线画图：https://www.processon.com/</description>
    </item>
    
  </channel>
</rss>