<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog on Renjie Blog</title>
    <link>https://renjie-zhang.github.io/categories/blog/</link>
    <description>Recent content in Blog on Renjie Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 13 Sep 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://renjie-zhang.github.io/categories/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Coding Common Problem</title>
      <link>https://renjie-zhang.github.io/post/2020-09-13-coding-issue/</link>
      <pubDate>Sun, 13 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://renjie-zhang.github.io/post/2020-09-13-coding-issue/</guid>
      <description>封装的错误 工作中很多语言都是面向对象的语言，面向对象的三大特征，有时候也是四大特性，我们常说的封装、继承、多态，四大特性就需要加上抽象。我们对对象进行封装是为了更好隐藏或者数据访问保护，但是并不是所有的属性都是可以进行get与set的。这便是我们常犯的一个错误，使用Lombok的注解@Getter与@Setter直接将所有的属性暴露了，此时封装便形同虚无，完全没有达到目的。 下面用极客时间王争设计模式之美课程的一个列子来说明：
public class Wallet { private String id; private long createTime; private BigDecimal balance; private long balanceLastModifiedTime; public String getId() { return id; } public long getCreateTime() { return createTime; } public BigDecimal getBalance() { return balance; } public long getBalanceLastModifiedTime() { return balanceLastModifiedTime; } public void increaseBalance(BigDecimal increasedAmount){ if(increasedAmount.compareTo(BigDecimal.ZERO) &amp;lt; 0){ throw new Exception(&amp;quot;...&amp;quot;); } this.balance.add(increasedAmount); this.balanceLastModifiedTime = System.currentTimeMillis(); } }  这是一个虚拟钱包的大概一个实现，在我们平常的开发中，并不是很重视get与set方法，直接使用注解@Getter与@Setter，也让在修改属性返回类型，修改属性名称时很方便；但是这并不是我们的目的。对于部分属性我们是不需要对外暴露set方法，只允许get。 对于balance并没有set方法，而是封装在$increaseBalance()中，因为在修改时，需要对参数进行校验，满足条件的参数才会进行修改，这便是我们的目的，使用封装来对数据进行保护。
未完</description>
    </item>
    
    <item>
      <title>约瑟夫环(Josephus) </title>
      <link>https://renjie-zhang.github.io/post/2019-08-31-josephus/</link>
      <pubDate>Tue, 03 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://renjie-zhang.github.io/post/2019-08-31-josephus/</guid>
      <description>约瑟夫问题 据说著名犹太历史学家 Josephus有过以下的故事：在罗马人占领乔塔帕特后，39 个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式：41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想遵从。首先从一个人开始，越过k-2个人（因为第一个人已经被越过），并杀掉第k个人。接着，再越过k-1个人，并杀掉第k个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。问题是一开始要站在什么地方才能避免自杀？Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。
问题即，给定人数、起点、方向和要跳过的数字，选择初始圆圈中的位置以避免被处决。
基本选择的解法是使用单项的循环链表模拟整个过程，时间复杂度为O(N*M),而空间复杂度为O(N)。或者使用数学公式递归的方式求出存活下来的编号。
循环链表解决 static void getPosition(int index,int total){ //first create a circle linked head Node head = new Node(1); Node prev = head; for(int i = 2;i&amp;lt;=total;i++){ prev.next = new Node(i); //move next prev = prev.next; } //create a cirecle linkedlist prev.next = head; // create two temp node Node ptr1 = head; Node ptr2 = head; while(ptr1.next != ptr1){ //find index-th node int count = 1; while (count !</description>
    </item>
    
    <item>
      <title>Queue</title>
      <link>https://renjie-zhang.github.io/post/2019-08-27-queue-ii/</link>
      <pubDate>Tue, 27 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://renjie-zhang.github.io/post/2019-08-27-queue-ii/</guid>
      <description>队列Ⅱ 使用数组实现队列的缺点是当存储的数据超过数组的长度之后就需要考虑扩容了，如果有无限排队的需求，那么就需要一个链表实现无限排队的队列，相比于数组实现队列，链表更加的简单。下面展示代码：
基于链表实现的方式（java） /** * @author: renjie.zhang * @date:2019/8/25-16:23 * @Description: 使用链表实现队列 */ public class LinkedListQueue { private Node head =new Node(0); public Node getHead() { return head; } /** * 队列入队操作 * @param node */ public void EnQueue(Node node){ Node temp = head; while (true){ if (temp.next == null){ break; } temp = temp.next; } temp.next = node; } /** * 队列出队操作 * @param head * @return */ public Node DeQueue(Node head){ if(head.</description>
    </item>
    
    <item>
      <title>Queue</title>
      <link>https://renjie-zhang.github.io/post/2019-08-22-queue/</link>
      <pubDate>Tue, 20 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://renjie-zhang.github.io/post/2019-08-22-queue/</guid>
      <description>队列Ⅰ 像堆栈一样，队列是一种线性结构，它遵循着执行操作的特定顺序。比如在开发中常用的线程池就是一个队列，当我们向固定大小的线程池中请求一个线程时，如果线程池中有空闲的资源，那么可以获得到到，但是如果没有空闲的资源，那么线程池的处理一般有两种；一种是非阻塞的处理方式，直接拒绝任务请求；另外一种是阻塞的方式，将请求排队，等到有空闲的线程时，取出排队的请求继续处理。当处理排队请求时，我们又希望公平地处理每一个请求，先进先服务。队列有基于链表与基于数组的实现方式。
 基于链表实现的队列可以实现一个无限排队的无界队列，但是可能导致过多请求排队，请求响应的时间过长，对于大部分资源有限又对响应时间敏感的系统，基于链表实现的无限排队的线程池是不适合的。 基于数据实现的队列可以实现一个有界队列，队列的大小有限，所以线程池中的排队请求超过队列的大小时，接下来的请求会被拒绝，这种对于响应时间敏感的系统来说更加的适合；但是队列的大小设置是一个十分重要的因素，队列大导致请求过多，队列小导致无法充分利用系统资源，发挥最大性能。  基于数组方式实现队列（java） public class ArrayQueue { //表示队列的最大容量 private int maxSize; //对列的头 private int front; //队列的尾 private int rear; //数组 private int[] arr; /** * 构造器 * @param arrMaxSize 队列的最大容量 */ public ArrayQueue(int arrMaxSize){ this.maxSize = arrMaxSize; this.arr = new int[maxSize]; //-1表示front的前一个位置 this.front = -1; //-1表示rear的最后一个数据 this.rear = -1; } /** *判断队列是否已装满 * @return */ public boolean isFull(){ return rear == maxSize-1; } /** * 判断队列是否为空 * @return */ public boolean isEmpty(){ return front == rear; } /** * 向队列中添加数据 * @param n 数据 */ public void addToQueue(int n){ if(isFull()){ System.</description>
    </item>
    
  </channel>
</rss>