<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Renjie Blog</title>
    <link>https://renjie-zhang.github.io/post/</link>
    <description>Recent content in Posts on Renjie Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 14 Mar 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://renjie-zhang.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Gin</title>
      <link>https://renjie-zhang.github.io/post/2020-3-14-gin-first/</link>
      <pubDate>Sat, 14 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://renjie-zhang.github.io/post/2020-3-14-gin-first/</guid>
      <description>Gin初体验 后端开发难免会接触到web,在Java的框架中spring一家独大，无论是web还是其他服务spring都是不二的选择；而golang的web方面选择特别的多，像gin,beego等，现在还处于不断造轮子的阶段，都在为开源做贡献，目前进行了一个Gin的初体验，总体上是让人很满意的，不管是gin还是beego都是以modules的这种形式，只允许加入自己需要的东西，减少负荷，以便加载到内存中的modules都是自己需要的。
特性都可以在gin的文档中寻找到，如果追求性能与高效，这是一个吸引人的亮点，在目前的开发中，都是最求极致的性能与高效。本来go已经在http中为我们做足了工作，建立起一个http请求及其简单。
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;net/http&amp;quot; &amp;quot;time&amp;quot; ) func greet(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, &amp;quot;Hello World! %s&amp;quot;, time.Now()) } func header(w http.ResponseWriter, req *http.Request) { for name, headers := range req.Header { for _, h := range headers { fmt.Fprintf(w, &amp;quot;%v: %v\n&amp;quot;, name, h) } } } func main() { http.HandleFunc(&amp;quot;/&amp;quot;, greet) http.HandleFunc(&amp;quot;/headers&amp;quot;, header) http.ListenAndServe(&amp;quot;:8080&amp;quot;, nil) }  这样便建立起了一个http server,监听在8080端口。而gin建立起一个请求更为简单，一下为入门例子。
package main import &amp;quot;github.com/gin-gonic/gin&amp;quot; func main() { r := gin.</description>
    </item>
    
    <item>
      <title>约瑟夫环(Josephus) </title>
      <link>https://renjie-zhang.github.io/post/2019-08-31-josephus/</link>
      <pubDate>Tue, 03 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://renjie-zhang.github.io/post/2019-08-31-josephus/</guid>
      <description>约瑟夫问题 据说著名犹太历史学家 Josephus有过以下的故事：在罗马人占领乔塔帕特后，39 个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式：41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想遵从。首先从一个人开始，越过k-2个人（因为第一个人已经被越过），并杀掉第k个人。接着，再越过k-1个人，并杀掉第k个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。问题是一开始要站在什么地方才能避免自杀？Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。
问题即，给定人数、起点、方向和要跳过的数字，选择初始圆圈中的位置以避免被处决。
基本选择的解法是使用单项的循环链表模拟整个过程，时间复杂度为O(N*M),而空间复杂度为O(N)。或者使用数学公式递归的方式求出存活下来的编号。
循环链表解决 static void getPosition(int index,int total){ //first create a circle linked head Node head = new Node(1); Node prev = head; for(int i = 2;i&amp;lt;=total;i++){ prev.next = new Node(i); //move next prev = prev.next; } //create a cirecle linkedlist prev.next = head; // create two temp node Node ptr1 = head; Node ptr2 = head; while(ptr1.next != ptr1){ //find index-th node int count = 1; while (count !</description>
    </item>
    
    <item>
      <title>Queue</title>
      <link>https://renjie-zhang.github.io/post/2019-08-27-queue-ii/</link>
      <pubDate>Tue, 27 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://renjie-zhang.github.io/post/2019-08-27-queue-ii/</guid>
      <description>队列Ⅱ 使用数组实现队列的缺点是当存储的数据超过数组的长度之后就需要考虑扩容了，如果有无限排队的需求，那么就需要一个链表实现无限排队的队列，相比于数组实现队列，链表更加的简单。下面展示代码：
基于链表实现的方式（java） /** * @author: renjie.zhang * @date:2019/8/25-16:23 * @Description: 使用链表实现队列 */ public class LinkedListQueue { private Node head =new Node(0); public Node getHead() { return head; } /** * 队列入队操作 * @param node */ public void EnQueue(Node node){ Node temp = head; while (true){ if (temp.next == null){ break; } temp = temp.next; } temp.next = node; } /** * 队列出队操作 * @param head * @return */ public Node DeQueue(Node head){ if(head.</description>
    </item>
    
    <item>
      <title>Queue</title>
      <link>https://renjie-zhang.github.io/post/2019-08-22-queue/</link>
      <pubDate>Tue, 20 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://renjie-zhang.github.io/post/2019-08-22-queue/</guid>
      <description>队列Ⅰ 像堆栈一样，队列是一种线性结构，它遵循着执行操作的特定顺序。比如在开发中常用的线程池就是一个队列，当我们向固定大小的线程池中请求一个线程时，如果线程池中有空闲的资源，那么可以获得到到，但是如果没有空闲的资源，那么线程池的处理一般有两种；一种是非阻塞的处理方式，直接拒绝任务请求；另外一种是阻塞的方式，将请求排队，等到有空闲的线程时，取出排队的请求继续处理。当处理排队请求时，我们又希望公平地处理每一个请求，先进先服务。队列有基于链表与基于数组的实现方式。
 基于链表实现的队列可以实现一个无限排队的无界队列，但是可能导致过多请求排队，请求响应的时间过长，对于大部分资源有限又对响应时间敏感的系统，基于链表实现的无限排队的线程池是不适合的。 基于数据实现的队列可以实现一个有界队列，队列的大小有限，所以线程池中的排队请求超过队列的大小时，接下来的请求会被拒绝，这种对于响应时间敏感的系统来说更加的适合；但是队列的大小设置是一个十分重要的因素，队列大导致请求过多，队列小导致无法充分利用系统资源，发挥最大性能。  基于数组方式实现队列（java） public class ArrayQueue { //表示队列的最大容量 private int maxSize; //对列的头 private int front; //队列的尾 private int rear; //数组 private int[] arr; /** * 构造器 * @param arrMaxSize 队列的最大容量 */ public ArrayQueue(int arrMaxSize){ this.maxSize = arrMaxSize; this.arr = new int[maxSize]; //-1表示front的前一个位置 this.front = -1; //-1表示rear的最后一个数据 this.rear = -1; } /** *判断队列是否已装满 * @return */ public boolean isFull(){ return rear == maxSize-1; } /** * 判断队列是否为空 * @return */ public boolean isEmpty(){ return front == rear; } /** * 向队列中添加数据 * @param n 数据 */ public void addToQueue(int n){ if(isFull()){ System.</description>
    </item>
    
  </channel>
</rss>